<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Reaction Diffusion</title>
    <style>
      body { margin: 0; }
      canvas { display: block; }
      #draw {
        position: absolute;
        top: 30%;
        width: 100%;
        font-size: 7rem;
        text-align: center;
        z-index: 100;
        opacity: 0.2;
        display: block;
        font-family: "Courier New", Courier, monospace;
        pointer-events: none;
      }
      #light {
        position: absolute;
        z-index: 101;
        opacity: 0.0;
        display: block;
        pointer-events: none;
        cursor: move;
        width: 5rem;
      }
    </style>
  </head>
  <body>
    <div id="draw">DRAW</div>
    <img id="light" src="data/day-sunny.svg" />
    <script src="js/external/three.min.js"></script>
    <script src="js/external/GPUComputationRenderer.min.js"></script>
    <script src="js/external/SimplexNoise.js"></script>
    <script src="js/external/dat.gui.min.js"></script>
    <script src="js/reaction-diffusion-fragment.js"></script>
    <script src="js/render-shaders.js"></script>
    <script>
      let width = window.innerWidth;
      let height = window.innerHeight;

      let simulation_width = Math.round(width * window.devicePixelRatio / 2.5);
      let simulation_height = Math.round(height * window.devicePixelRatio / 2.5);

      let scene = new THREE.Scene();

      let camera = new THREE.OrthographicCamera(width / - 2, width / 2, height / 2, height / - 2, 1, 1000);
      camera.position.z = 5;

      let renderer = new THREE.WebGLRenderer({precision: "highp"});
      renderer.setSize(width, height);
      document.body.appendChild(renderer.domElement);

      let light_pos = new THREE.Vector2(simulation_width/2, simulation_height/2);
      let mouse_down = false;
      let light_move = false;
      let brush_move = false;

      let clock = new THREE.Clock;
      let geometry = new THREE.PlaneGeometry(width, height, 1, 1);
      let material = new THREE.ShaderMaterial
      ({ 
        vertexShader: render_vertex,
        fragmentShader: render_fragment,
        uniforms: { 
          "reaction_diffusion": { value: null }, 
          "resolution": { value: new THREE.Vector2(simulation_width, simulation_height) },
          "time": { value: clock.getElapsedTime() },
          "light_pos": { value: new THREE.Vector3(light_pos.x, light_pos.y, 600) },
          "substance_color": { value: new THREE.Vector3(0.196078, 0.619608, 0.658824) },
          "background_color": { value: new THREE.Vector3(0.9, 0.9, 0.9) },
          "shininess": { value: 128.0 }
        }
      });
      let plane = new THREE.Mesh( geometry, material );
      scene.add(plane);

      let gpu_compute = new THREE.GPUComputationRenderer(simulation_width, simulation_height, renderer);

      let reaction_diffusion = gpu_compute.createTexture();

      let reaction_diffusion_variable = gpu_compute.addVariable(
        "reaction_diffusion", 
        reaction_diffusion_fragment,
        reaction_diffusion
      );

      gpu_compute.setVariableDependencies(reaction_diffusion_variable, [reaction_diffusion_variable]);

      reaction_diffusion_uniforms = reaction_diffusion_variable.material.uniforms;

      reaction_diffusion_uniforms['mouse_pos'] = { value: new THREE.Vector2(-100, -100) };
      reaction_diffusion_uniforms['mouse_down'] = { value: false };
      reaction_diffusion_uniforms['feed'] = { value: 0.042 };
      reaction_diffusion_uniforms['kill'] = { value: 0.06 };
      reaction_diffusion_uniforms['diffusion_scale'] = { value: 2.5 };
      reaction_diffusion_uniforms['feed_variation'] = { value: 0.001 };
      reaction_diffusion_uniforms['kill_variation'] = { value: 0.001 };
      reaction_diffusion_uniforms['diffusion_scale_variation'] = { value: 1.5 };
      reaction_diffusion_uniforms['anisotropy'] = { value: 0.7 };

      let simulation_iterations_per_frame = 4;
      let environment_noise_scale = 250;

      settings();

      createEnvironment();

      let light_element = document.getElementById('light');
      let light_half_dim = light_element.clientWidth / 2;
      updateLightPosition(new THREE.Vector2(width/2, height/2));

      function onMove(clientX, clientY)
      {
        let x = clientX * (simulation_width / width);
        let y = simulation_height - clientY * (simulation_height / height);

        reaction_diffusion_uniforms['mouse_pos'].value = new THREE.Vector2(x, y);

        if(mouse_down)
        {
          let mouse_pos = new THREE.Vector2(clientX, height - clientY);
          if(light_move || mouse_pos.distanceTo(light_pos) < light_half_dim)
          {
            light_move = true;
            brush_move = false;
            updateLightPosition(mouse_pos);
            material.uniforms["light_pos"].value = new THREE.Vector3(x, y, 600);
          }
          else
          {
            brush_move = true;
            light_move = false;
          }
        }
        reaction_diffusion_uniforms['mouse_down'].value = brush_move;
      }

      function onUp()
      {
        mouse_down = light_move = brush_move = false;
        reaction_diffusion_uniforms['mouse_down'].value = false;
      }

      let draw_text_removed = false;
      function onDown()
      {
        mouse_down = true;

        if(!draw_text_removed)
        {
          light_element.style.opacity = 0.6;
          document.getElementById('draw').remove();
          draw_text_removed = true;
        }
      }

      renderer.domElement.onmousemove = function(event)
      {
        onMove(event.clientX, event.clientY);
      }

      renderer.domElement.onmousedown = function(event)
      {
        onDown();
      }

      renderer.domElement.onmouseup = onUp;
      renderer.domElement.onmouseleave = onUp;

      function touchStart(event) 
      {
        if(event.touches.length == 1)
        {
          onDown();
        }
      }

      function touchMove(event)
      {
        if(event.touches.length == 1)
        {
          event.preventDefault();
          onMove(event.touches[0].clientX, event.touches[0].clientY);
        }
      }

      function touchEnd(event) 
      {
        if(event.touches.length == 0)
        {
          onUp();
        }
      }

      function touchCancel(event) 
      {
        if(event.touches.length == 0)
        {
          onUp();
        }
      }

      renderer.domElement.addEventListener("touchstart", touchStart, false);
      renderer.domElement.addEventListener("touchend", touchEnd, false);
      renderer.domElement.addEventListener("touchcancel", touchCancel, false);
      renderer.domElement.addEventListener("touchmove", touchMove, false);

      reaction_diffusion_variable.wrapS = THREE.ClampToEdgeWrapping;
      reaction_diffusion_variable.wrapT = THREE.ClampToEdgeWrapping;

      gpu_compute.init();

      function animate() 
      {
        requestAnimationFrame(animate);
        render();
      }

      animate();
      
      function render()
      {
        let time = clock.getElapsedTime();

        simulateReactionDiffusion(simulation_iterations_per_frame);
        material.uniforms["reaction_diffusion"].value = gpu_compute.getCurrentRenderTarget(reaction_diffusion_variable).texture;
        material.uniforms["time"].value = time;

        renderer.render(scene, camera);
      }

      function simulateReactionDiffusion(iterations)
      {
        for(let i = 0; i < iterations; i++)
        {
          gpu_compute.compute();
        }
      }

      function updateLightPosition(pos)
      {
        if(pos.x - light_half_dim > 0 && pos.x + light_half_dim < width && 
           pos.y - light_half_dim > 0 && pos.y + light_half_dim < height)
        {
          light_pos = pos;
          light_element.style.top = height - pos.y - light_half_dim + "px";
          light_element.style.left = pos.x - light_half_dim + "px";
        }
      }

      function createEnvironment()
      {
        let simplex = new THREE.SimplexNoise();

        //feed 0.072 0.045 0.042 0.014 0.037
        //kill 0.062 0.06  0.06  0.04  0.06

        let pixels = new Float32Array(simulation_width * simulation_height * 4);
        let p = 0;
        for (let y = 0; y < simulation_height; y++)
        {
          for (let x = 0; x < simulation_width; x++ )
          {
            pixels[p + 0] = simplex.noise3d(x / environment_noise_scale, y / environment_noise_scale, 0);
            pixels[p + 1] = simplex.noise3d(x / environment_noise_scale, y / environment_noise_scale, 1000);
            pixels[p + 2] = simplex.noise3d(x / environment_noise_scale, y / environment_noise_scale, 2000);
            pixels[p + 3] = simplex.noise3d(x / environment_noise_scale, y / environment_noise_scale, 3000);
            p += 4;
          }
        }

        reaction_diffusion_uniforms['environment'] = { 
          value: new THREE.DataTexture(pixels, simulation_width, simulation_height, THREE.RGBAFormat, THREE.FloatType) 
        };

        reaction_diffusion_uniforms.environment.value.magFilter = THREE.LinearFilter;
        reaction_diffusion_uniforms.environment.value.minFilter = THREE.LinearFilter;
      }

      function settings()
      {
        let gui = new dat.GUI();

        gui.width = 300;

        function variationProperty(value, variation, name, min0, max0, step0, min1, max1, step1)
        {
          this.Value = value;
          this.Variation = variation;
          this.folder = gui.addFolder(name);
          this.uniform0 = name.replace(/ /g,"_").toLowerCase();
          this.uniform1 = this.uniform0 + "_variation";
          this.ValueController = this.folder.add(this, "Value", min0, max0, step0);
          this.ValueController.onChange(() => {
            reaction_diffusion_uniforms[this.uniform0].value = this.Value;
          });
          this.VariationController = this.folder.add(this, "Variation", min1, max1, step1);
          this.VariationController.onChange(() => {
            reaction_diffusion_uniforms[this.uniform1].value = this.Variation;
          });
        }

        const min_diffusion_scale = 0.5;

        let DS_prop = new variationProperty(2.5, 1.5, "Diffusion Scale", min_diffusion_scale, 10, 0.01, 0, 2.5 - min_diffusion_scale, 0.01);
        let F_prop = new variationProperty(0.06, 0.001, "Feed", 0.01, 0.1, 0.0001, 0, 0.01, 0.0001);
        let K_prop = new variationProperty(0.042, 0.001, "Kill", 0.01, 0.1, 0.0001, 0, 0.01, 0.0001);

        function changeDS()
        {
          let max_variation = DS_prop.Value - min_diffusion_scale;
          if(max_variation <  DS_prop.Variation)
          {
            DS_prop.Variation = max_variation;
          }

          DS_prop.VariationController.max(max_variation);
          DS_prop.VariationController.updateDisplay();

          reaction_diffusion_uniforms['diffusion_scale'].value = DS_prop.Value;
          reaction_diffusion_uniforms['diffusion_scale_variation'].value = DS_prop.Variation;
        }

        DS_prop.ValueController.onChange(changeDS);
        DS_prop.VariationController.onChange(changeDS);

        let non_variation = { 
          anisotropy: 0.7, 
          speed: simulation_iterations_per_frame, 
          environment_scale: 250,
          update_environment: createEnvironment,
          background_color: [229, 229, 229],
          substance_color: [50, 158, 168],
          shininess: 64.0
        };

        gui.add(non_variation, 'anisotropy', 0.2, 0.8, 0.01).onChange(() => {
          reaction_diffusion_uniforms['anisotropy'].value = non_variation.anisotropy;
        }).name('Anisotropy');

        gui.add(non_variation, 'speed', 1, 32, 1).onChange(() => {
          simulation_iterations_per_frame = non_variation.speed;
        }).name('Iterations/Frame');

        environment_folder = gui.addFolder('Environment');

        environment_folder.add(non_variation, 'environment_scale', 1, 1000, 1).onChange(() => {
          environment_noise_scale = non_variation.environment_scale;
        }).name('Noise Scale');

        environment_folder.add(non_variation, 'update_environment').name('Update');

        gui.addColor(non_variation, 'substance_color').onChange(() => {
          material.uniforms.substance_color.value.x = non_variation.substance_color[0] / 255;
          material.uniforms.substance_color.value.y = non_variation.substance_color[1] / 255;
          material.uniforms.substance_color.value.z = non_variation.substance_color[2] / 255;
        }).name("Substance");

        gui.addColor(non_variation, 'background_color').onChange(() => {
          material.uniforms.background_color.value.x = non_variation.background_color[0] / 255;
          material.uniforms.background_color.value.y = non_variation.background_color[1] / 255;
          material.uniforms.background_color.value.z = non_variation.background_color[2] / 255;
        }).name("Background");

        gui.add(non_variation, 'shininess', 8, 512, 1).onChange(() => {
          material.uniforms.shininess.value = non_variation.shininess;
        }).name('Phong Shininess');

        gui.close();
      }

    </script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-156004912-1', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>