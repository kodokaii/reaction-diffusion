<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Reaction Diffusion</title>
    <style>
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
    </style>
  </head>
  <body>
    <script src="js/external/three.min.js"></script>
    <script src="js/external/GPUComputationRenderer.min.js"></script>
    <script src="js/reaction-diffusion-fragment.js"></script>
    <script src="js/render-shaders.js"></script>
    <script>
      var width = 1024;
      var height = 1024;
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(12, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;

      var renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      var geometry = new THREE.PlaneGeometry(1, 1, 1, 1);
      var material = new THREE.ShaderMaterial
      ({ 
        vertexShader: render_vertex,
        fragmentShader: render_fragment,
        uniforms: { "reaction_diffusion": { value: null }}
      });
      var plane = new THREE.Mesh( geometry, material );
      scene.add(plane);

      var gpu_compute = new THREE.GPUComputationRenderer(width, height, renderer);
      var reaction_diffusion = gpu_compute.createTexture();

      setInitialState(reaction_diffusion);

      var reaction_diffusion_variable = gpu_compute.addVariable("reaction_diffusion", reaction_diffusion_fragment, reaction_diffusion);

      gpu_compute.setVariableDependencies(reaction_diffusion_variable, [reaction_diffusion_variable]);

      reaction_diffusion_variable.material.uniforms['resolution'] = { value: new THREE.Vector2(width, height) };

      reaction_diffusion_variable.wrapS = THREE.RepeatWrapping;
      reaction_diffusion_variable.wrapT = THREE.RepeatWrapping;

      var error = gpu_compute.init();
      if ( error !== null ) 
      {
        console.error(error);
      }

      setInterval( () => { gpu_compute.compute(); }, 1 );

      function animate() 
      {
        requestAnimationFrame(animate);
        render();
        renderer.render(scene, camera);
      }

      animate();
      
      function render()
      {
        material.uniforms["reaction_diffusion"].value = gpu_compute.getCurrentRenderTarget(reaction_diffusion_variable).texture;
      }

      function setInitialState(texture) 
      {
        var min_radius = 4;
        var max_radius = 64;
        var points = new Array(16);

        for (var i = 0; i < points.length; i++) 
        {
          var radius = min_radius + Math.random() * (max_radius - min_radius);
          points[i] = [Math.random() * width, Math.random() * height, radius];
        }

        function distance(p1, p2)
        {
          return Math.sqrt(Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2));
        }

        var pixels = texture.image.data;
        var p = 0;
        for (var x = 0; x < width; x++ ) 
        {
          for (var y = 0; y < height; y++)
          {
            pixels[p + 0] = 1;
            pixels[p + 1] = 0;
            pixels[p + 2] = 0;
            pixels[p + 3] = 1;

            for (var i = 0; i < points.length; i++)
            {
              var dist = distance([x,y], points[i]);
              if(dist < points[i][2])
              {
                pixels[p + 1] = Math.random() > 0.95;
              }
            }

            p += 4;
          }
        }
      }

    </script>
  </body>
</html>